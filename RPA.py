# -*- coding: utf-8 -*-

# TODO: move all Selenium related functionality to web.py
# TODO: do a simple interactive Dashboard showing the results of automation
    # the simplest possible: using print()

    # The logic of the automation:
    #   logging in >> using models/login.py
    #   getting the list of test cases and iterating thought them
    #       if untested submit results as passed >> using models/submit_testcase.py

## Results
#   1. Script successfully submits all untested test cases as Passed with all the fields filled correctly
#   2. The results of automation script are printed on the Dashboard in real time
#   3. The user is supposed to enter username and password by himself, manually
#   4. Script should at any moment of time be aware of the state of the TestRun
#       Assuming that other users can submit their results at any moment as well
#       script needs to check the actual state before executing actions
#   5. All the Selenium logic is in automation/web.py
#        reading and executing next_steps.json
#        need to be extended to allow more Selenium actions in next_steps.json
#   6. automation/next_steps.json is generated by
#       models/login.py             steps Selenium needs to do to allow user to enter his username and password
#       models/submit_testcase.py   steps Selenium need to submit 1 testcase

## Hints:
# If Testrun is used, create a new one using Rerun button at the right of the TestRun title

import json
import time
import unittest

from selenium import webdriver
from selenium.common.exceptions import NoAlertPresentException
from selenium.common.exceptions import NoSuchElementException

from automation import web

# Starting testcases
class Helper(unittest.TestCase):
    """
    Selenium helper
    ----------
    It is a core class to run tests using Selenium library
    """
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.implicitly_wait(30)
        self.base_url = "http://localhost/"
        self.verificationErrors = []
        self.accept_next_alert = True

    def test_interactiveRPA(self):
        """
        The main logic of interactive testing.

        ---
        `test_` added to run under unittest
        """
        driver = self.driver

        # Testrun variables
        testrun_url = 'https://lifecycletest3.testrail.io/index.php?/runs/view/1'
        testrun_id = 'R1'
        version = '0.1'
        elapsed = '1m'

        ## for your information (user needs to enter them manually)
        username = 'guest@lifecycle.today'
        password = "Pass1234!"

        # Load the testrun page
        driver.get(testrun_url)

        # TODO: login

        # if login screen
            # url contains /auth/login
            # page has "Log into Your Account" text
        # execute login steps from login.py until next_steps.json is empty

        #TODO: Pass all untested test cases

    def is_element_present(self, how, what):
        try:
            self.driver.find_element(by=how, value=what)
        except NoSuchElementException as e:
            return False
        return True

    def is_alert_present(self):
        try:
            self.driver.switch_to.alert
        except NoAlertPresentException as e:
            return False
        return True

    def close_alert_and_get_its_text(self):
        try:
            alert = self.driver.switch_to.alert
            alert_text = alert.text
            if self.accept_next_alert:
                alert.accept()
            else:
                alert.dismiss()
            return alert_text
        finally:
            self.accept_next_alert = True

    def tearDown(self):
        self.driver.quit()
        self.assertEqual([], self.verificationErrors)

    #TODO: Extend actions for next_steps.json
    def executeStep(self, selector_type, selector, action_type, wait=True):
        driver = self.driver
        # Run a step with selenium driver
        try:
            if selector_type == "css":
                if action_type == "click":
                    driver.find_element_by_css_selector(selector).click()
            if selector_type == "url":
                if action_type == "get":
                    driver.get(selector)
            print("Executing action " + action_type + " on " + selector_type + ":" + selector + " -- Success")
        except:
            print("Executing action " + action_type + " on " + selector_type + ":" + selector + " -- Failure")
        # waiting, so that user can see what's going on
        if wait:
            time.sleep(2)

    def executeSteps(self, steps_json_url):
        # Read the json file
        # print("Loading next steps from json file")
        with open(steps_json_url) as json_file:
            next_steps_json = json.loads(json_file.read())

        # Get the list of steps and execute them
        for step in next_steps_json["steps"]:
            # TODO: add exception handling in case json has variable structure OR make the fields in json obligatory
            selector_type = step["selectorType"]
            selector = step["selector"]
            action_type = step["action"]
            self.executeStep(selector_type, selector, action_type)


if __name__ == "__main__":
    unittest.main()
